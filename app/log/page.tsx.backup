'use client'

import { useState, useEffect, useRef } from 'react'
import { supabase } from '@/lib/supabase'

interface LogEntry {
  id: string
  task_code: string
  status_code: string
  work_description: string
  date: string
  start_time: string
  end_time?: string
  is_parallel: boolean
  track_number: number
  created_at: string
}

interface Task {
  id: string
  code: string
  base_code: string
  title: string
  status: string
  current_status?: string
  current_status_name?: string
  universe_code?: string
  updated_at: string
}

interface Card {
  id: string
  card_number: string
  start_date: string
  end_date?: string
  status: string
}

interface DraggedItem {
  type: 'task' | 'entry'
  task?: Task
  entry?: LogEntry
}

interface DragState {
  isDragging: boolean
  draggedItem: DraggedItem | null
  startPos: { x: number; y: number }
  currentPos: { x: number; y: number }
  dragElement: HTMLElement | null
}

export default function LogPage() {
  const [currentDate, setCurrentDate] = useState(new Date())
  const [entries, setEntries] = useState<LogEntry[]>([])
  const [activeTasks, setActiveTasks] = useState<Task[]>([])
  const [currentCard, setCurrentCard] = useState<Card | null>(null)
  const [selectedEntry, setSelectedEntry] = useState<LogEntry | null>(null)
  const [showTaskPanel, setShowTaskPanel] = useState(false)
  const [isMobile, setIsMobile] = useState(false)
  const [isHydrated, setIsHydrated] = useState(false)
  const [currentTime, setCurrentTime] = useState(new Date())
  const [hoveredHour, setHoveredHour] = useState<number | null>(null)

  // New mouse-based drag state
  const [dragState, setDragState] = useState<DragState>({
    isDragging: false,
    draggedItem: null,
    startPos: { x: 0, y: 0 },
    currentPos: { x: 0, y: 0 },
    dragElement: null
  })
  const [showEntryPanel, setShowEntryPanel] = useState(false)
  const [selectedTimeSlot, setSelectedTimeSlot] = useState<string>('')

  const calendarRef = useRef<HTMLDivElement>(null)

  // Hydration-safe mobile detection
  useEffect(() => {
    setIsHydrated(true)
    const checkMobile = () => setIsMobile(window.innerWidth < 768)
    checkMobile()
    window.addEventListener('resize', checkMobile)
    return () => window.removeEventListener('resize', checkMobile)
  }, [])

  // Update current time every minute - only after hydration
  useEffect(() => {
    if (!isHydrated) return

    setCurrentTime(new Date()) // Set initial time
    const timer = setInterval(() => {
      setCurrentTime(new Date())
    }, 60000)
    return () => clearInterval(timer)
  }, [isHydrated])

  // Load data on date change
  useEffect(() => {
    loadEntries()
    loadCurrentCard()
  }, [currentDate])

  // Run cleanup once on mount
  useEffect(() => {
    cleanupQCKEntries()
  }, [])

  // Load active tasks when panel opens
  useEffect(() => {
    if (showTaskPanel) {
      loadActiveTasks()
    }
  }, [showTaskPanel])

  // Time calculation utilities
  const timeToMinutes = (time: string): number => {
    const [hour, min] = time.split(':').map(Number)
    return hour * 60 + min
  }

  const snapToQuarter = (minutes: number): number => {
    return Math.round(minutes / 15) * 15
  }

  const minutesToTime = (minutes: number): string => {
    const hours = Math.floor(minutes / 60)
    const mins = minutes % 60
    return `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}`
  }

  // Mac Dock-style magnification for hours
  const getHourHeight = (hour: number): number => {
    if (!hoveredHour && !dragState.isDragging) return 40 // Compact default

    const targetHour = dragState.isDragging ? hoveredHour : hoveredHour
    if (!targetHour) return 40

    const distance = Math.abs(hour - targetHour)
    // Smoother magnification curve
    if (distance === 0) return 120  // Focused hour - fully expanded
    if (distance === 1) return 90   // Adjacent hours - mostly expanded
    if (distance === 2) return 65   // Near hours - moderately expanded
    if (distance === 3) return 50   // Distant hours - slight expansion
    return 40 // Normal compact
  }

  // Calculate total calendar height for consistent sizing
  const getTotalCalendarHeight = (): number => {
    if (!hoveredHour && !dragState.isDragging) return 40 * 15 // Compact: 40px * 15 hours

    let total = 0
    for (let hour = 7; hour <= 21; hour++) {
      total += getHourHeight(hour)
    }
    return total
  }

  // Clean up auto-created QCK entries (run once)
  const cleanupQCKEntries = async () => {
    const { data: qckEntries } = await supabase
      .from('calendar_entries')
      .select('id')
      .like('task_code', 'QCK-%')

    if (qckEntries && qckEntries.length > 0) {
      await supabase
        .from('calendar_entries')
        .delete()
        .like('task_code', 'QCK-%')
    }
  }

  // Load functions
  const loadEntries = async () => {
    const { data } = await supabase
      .from('calendar_entries')
      .select('*')
      .eq('date', currentDate.toISOString().split('T')[0])
      .order('start_time')

    setEntries(data || [])
  }

  const loadActiveTasks = async () => {
    const { data: tasks } = await supabase
      .from('task_details')
      .select('*')
      .in('current_status', ['R', 'P', 'D'])
      .order('updated_at', { ascending: false })
      .limit(30)

    setActiveTasks(tasks || [])
  }

  const loadCurrentCard = async () => {
    const { data } = await supabase
      .from('cards')
      .select('*')
      .eq('status', 'active')
      .single()

    setCurrentCard(data)
  }

  // Entry management functions
  const createEntryAtTime = async (task: Task, time: string) => {
    const endTime = minutesToTime(timeToMinutes(time) + 60) // Default 1 hour

    await supabase
      .from('calendar_entries')
      .insert({
        task_code: task.base_code || task.code,
        status_code: 'P',
        work_description: task.title,
        date: currentDate.toISOString().split('T')[0],
        start_time: time,
        end_time: endTime,
        is_parallel: false,
        track_number: 1
      })

    loadEntries()
  }

  const updateEntryTime = async (entryId: string, newStartTime: string, newEndTime?: string) => {
    const updates: any = { start_time: newStartTime }
    if (newEndTime) {
      updates.end_time = newEndTime
    }

    await supabase
      .from('calendar_entries')
      .update(updates)
      .eq('id', entryId)

    loadEntries()
  }

  const updateEntryStatus = async (entryId: string, statusCode: string) => {
    await supabase
      .from('calendar_entries')
      .update({ status_code: statusCode })
      .eq('id', entryId)

    loadEntries()
  }

  const deleteEntry = async (entryId: string) => {
    await supabase
      .from('calendar_entries')
      .delete()
      .eq('id', entryId)

    setSelectedEntry(null)
    loadEntries()
  }

  // Color coding functions
  const getTaskColor = (taskCode: string) => {
    const firstLetter = taskCode.charAt(0).toUpperCase()
    switch (firstLetter) {
      case 'W': return 'bg-blue-500 border-blue-600 text-white'
      case 'A': return 'bg-green-500 border-green-600 text-white'
      case 'C': return 'bg-purple-500 border-purple-600 text-white'
      default: return 'bg-gray-500 border-gray-600 text-white'
    }
  }

  const getStatusColor = (statusCode: string) => {
    switch (statusCode) {
      case 'R': return 'bg-blue-100 dark:bg-blue-900/20 border-blue-500'
      case 'P': return 'bg-yellow-100 dark:bg-yellow-900/20 border-yellow-500'
      case 'D': return 'bg-purple-100 dark:bg-purple-900/20 border-purple-500'
      case 'C': return 'bg-green-100 dark:bg-green-900/20 border-green-500'
      case 'X': return 'bg-red-100 dark:bg-red-900/20 border-red-500'
      default: return 'bg-gray-100 dark:bg-gray-800 border-gray-500'
    }
  }

  // Mouse-based drag handlers (no more HTML5 drag API)
  const handleMouseDown = (e: React.MouseEvent, item: DraggedItem) => {
    // Prevent text selection
    e.preventDefault()
    document.getSelection()?.removeAllRanges()

    const startPos = { x: e.clientX, y: e.clientY }

    // Create drag element clone
    const sourceElement = e.currentTarget as HTMLElement
    const dragElement = sourceElement.cloneNode(true) as HTMLElement

    // Style drag element
    dragElement.style.position = 'fixed'
    dragElement.style.pointerEvents = 'none'
    dragElement.style.zIndex = '10000'
    dragElement.style.opacity = '0.8'
    dragElement.style.transform = 'rotate(2deg) scale(1.05)'
    dragElement.style.left = `${startPos.x}px`
    dragElement.style.top = `${startPos.y}px`
    document.body.appendChild(dragElement)

    setDragState({
      isDragging: true,
      draggedItem: item,
      startPos,
      currentPos: startPos,
      dragElement
    })

    // Prevent text selection on document
    document.body.style.userSelect = 'none'
    document.body.style.webkitUserSelect = 'none'
  }

  const handleMouseMove = (e: MouseEvent) => {
    if (!dragState.isDragging || !dragState.dragElement) return

    const currentPos = { x: e.clientX, y: e.clientY }

    // Update drag element position
    dragState.dragElement.style.left = `${currentPos.x - 20}px`
    dragState.dragElement.style.top = `${currentPos.y - 20}px`

    setDragState(prev => ({ ...prev, currentPos }))

    // Update hover state for magnification
    const calendarElement = calendarRef.current
    if (calendarElement) {
      const rect = calendarElement.getBoundingClientRect()
      if (e.clientX >= rect.left && e.clientX <= rect.right &&
          e.clientY >= rect.top && e.clientY <= rect.bottom) {
        const hour = Math.floor((e.clientY - rect.top) / 64) + 7
        setHoveredHour(hour)
      } else {
        setHoveredHour(null)
      }
    }
  }

  const handleMouseUp = (e: MouseEvent) => {
    if (!dragState.isDragging) return

    // Clean up drag element
    if (dragState.dragElement) {
      document.body.removeChild(dragState.dragElement)
    }

    // Restore text selection
    document.body.style.userSelect = ''
    document.body.style.webkitUserSelect = ''

    // Check if dropped on calendar
    const calendarElement = calendarRef.current
    if (calendarElement && dragState.draggedItem) {
      const rect = calendarElement.getBoundingClientRect()
      if (e.clientX >= rect.left && e.clientX <= rect.right &&
          e.clientY >= rect.top && e.clientY <= rect.bottom) {

        // Calculate target time with proper 15-minute slot detection
        let cumulativeHeight = 0
        let targetHour = 7
        let targetQuarter = 0

        // Find which hour and quarter we're in
        for (let hour = 7; hour <= 21; hour++) {
          const hourHeight = getHourHeight(hour)
          if (e.clientY - rect.top < cumulativeHeight + hourHeight) {
            targetHour = hour
            // Within this hour, find the quarter
            const withinHour = (e.clientY - rect.top) - cumulativeHeight
            const quarterHeight = hourHeight / 4
            targetQuarter = Math.floor(withinHour / quarterHeight)
            // Clamp to valid quarters (0, 1, 2, 3)
            targetQuarter = Math.min(Math.max(targetQuarter, 0), 3)
            break
          }
          cumulativeHeight += hourHeight
        }

        const targetMinutes = targetHour * 60 + (targetQuarter * 15)
        // Ensure we stay within valid time bounds
        const clampedMinutes = Math.max(7 * 60, Math.min(targetMinutes, 21 * 60 + 45))

        // Handle drop
        if (dragState.draggedItem.type === 'task' && dragState.draggedItem.task) {
          createEntryAtTime(dragState.draggedItem.task, minutesToTime(clampedMinutes))
        } else if (dragState.draggedItem.type === 'entry' && dragState.draggedItem.entry) {
          const duration = dragState.draggedItem.entry.end_time
            ? timeToMinutes(dragState.draggedItem.entry.end_time) - timeToMinutes(dragState.draggedItem.entry.start_time)
            : 60
          const newEndTime = minutesToTime(clampedMinutes + duration)
          updateEntryTime(dragState.draggedItem.entry.id, minutesToTime(clampedMinutes), newEndTime)
        }
      }
    }

    // Reset drag state
    setDragState({
      isDragging: false,
      draggedItem: null,
      startPos: { x: 0, y: 0 },
      currentPos: { x: 0, y: 0 },
      dragElement: null
    })
    setHoveredHour(null)
  }

  // Add mouse event listeners
  useEffect(() => {
    if (dragState.isDragging) {
      document.addEventListener('mousemove', handleMouseMove)
      document.addEventListener('mouseup', handleMouseUp)
      return () => {
        document.removeEventListener('mousemove', handleMouseMove)
        document.removeEventListener('mouseup', handleMouseUp)
      }
    }
  }, [dragState.isDragging])



  // Navigation
  const navigate = (direction: 'prev' | 'next') => {
    const newDate = new Date(currentDate)
    newDate.setDate(newDate.getDate() + (direction === 'next' ? 1 : -1))
    setCurrentDate(newDate)
  }

  const formatDate = () => {
    if (!isHydrated) return 'LOADING...'

    return currentDate.toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      weekday: 'long'
    }).toUpperCase()
  }

  // Task Panel Component
  const TaskPanel = () => {
    // Local search state to prevent parent re-renders
    const [localSearchQuery, setLocalSearchQuery] = useState('')

    if (!isHydrated) return null

    // Filter tasks locally to avoid parent re-renders
    const filteredTasks = activeTasks.filter(task =>
      !localSearchQuery ||
      task.title.toLowerCase().includes(localSearchQuery.toLowerCase()) ||
      task.base_code?.toLowerCase().includes(localSearchQuery.toLowerCase()) ||
      task.code.toLowerCase().includes(localSearchQuery.toLowerCase())
    )

    return (
      <div className={`${
        isMobile
          ? 'fixed bottom-0 left-0 right-0 bg-white dark:bg-gray-900 border-t-2 border-gray-300 dark:border-gray-700 z-30 transition-transform duration-300 ease-out'
          : 'fixed right-0 top-0 h-full w-80 bg-white dark:bg-gray-900 border-l-2 border-gray-300 dark:border-gray-700 z-30 transition-transform duration-300 ease-out'
      } ${
        showTaskPanel ? 'translate-y-0 translate-x-0' : isMobile ? 'translate-y-full' : 'translate-x-full'
      }`}
      style={isMobile ? { height: '60vh' } : {}}>
        <div className="p-4 h-full flex flex-col">
          <div className="flex justify-between items-center mb-4">
            <h2 className="font-mono font-bold text-lg">TASK INVENTORY</h2>
            <button
              onClick={() => setShowTaskPanel(false)}
              className="p-2 hover:bg-gray-200 dark:hover:bg-gray-700 rounded"
            >
              ×
            </button>
          </div>

          <div className="mb-4">
            <input
              type="text"
              placeholder="Search tasks..."
              value={localSearchQuery}
              onChange={(e) => setLocalSearchQuery(e.target.value)}
              className="w-full px-3 py-2 font-mono bg-gray-50 dark:bg-gray-800 border rounded focus:outline-none focus:ring-2 focus:ring-blue-500 text-sm"
            />
          </div>

          {currentCard && (
            <div className="mb-6">
              <h3 className="font-mono font-bold text-sm mb-2">CURRENT CARD: {currentCard.card_number}</h3>
              <div className="text-xs text-gray-500 mb-3">
                Started {new Date(currentCard.start_date).toLocaleDateString()}
              </div>
            </div>
          )}

          <div className="flex-1 overflow-y-auto space-y-2">
            {filteredTasks.map((task) => (
              <div
                key={task.id}
                onMouseDown={(e) => handleMouseDown(e, { type: 'task', task })}
                className={`p-2 border-2 border-l-4 rounded cursor-move font-mono text-xs transition-all hover:shadow-md select-none ${
                  getTaskColor(task.base_code || task.code)
                } ${
                  dragState.isDragging && dragState.draggedItem?.task?.id === task.id ? 'opacity-50 scale-95' : 'opacity-100 scale-100'
                }`}
              >
                <div className="font-bold">{task.base_code || task.code}</div>
                <div className="text-xs mt-1 opacity-75 truncate">{task.title}</div>
                {task.current_status_name && (
                  <div className="text-xs mt-1 opacity-60">{task.current_status_name}</div>
                )}
              </div>
            ))}
          </div>
        </div>
      </div>
    )
  }

  // Calendar Grid Component with Mac Dock-style Magnification
  const CalendarGrid = () => {
    const hours = Array.from({ length: 15 }, (_, i) => i + 7) // 7 AM to 9 PM
    const currentHour = currentTime.getHours()
    const currentMinute = currentTime.getMinutes()
    const showCurrentTime = isHydrated && currentHour >= 7 && currentHour <= 21

    return (
      <div
        ref={calendarRef}
        className="bg-white dark:bg-gray-900 rounded border border-gray-300 dark:border-gray-700 overflow-hidden"
        style={{ height: getTotalCalendarHeight() }}
        onMouseLeave={() => !dragState.isDragging && setHoveredHour(null)}
      >
        <div className="flex h-full">
          {/* Time Labels Column */}
          <div className="w-16 bg-gray-50 dark:bg-gray-800 border-r border-gray-300 dark:border-gray-600 flex flex-col">
            {hours.map((hour) => {
              const hourHeight = getHourHeight(hour)
              const isExpanded = hourHeight > 40

              return (
                <div
                  key={hour}
                  className="flex items-center justify-end pr-2 border-b border-gray-200 dark:border-gray-700 transition-all duration-300 ease-out"
                  style={{ height: `${hourHeight}px` }}
                >
                  <div className="text-center">
                    <span className="text-xs font-mono text-gray-500 font-bold">
                      {hour.toString().padStart(2, '0')}:00
                    </span>
                    {isExpanded && hourHeight >= 120 && (
                      <div className="text-xs font-mono text-gray-400 mt-1 space-y-0.5">
                        <div>:15</div>
                        <div>:30</div>
                        <div>:45</div>
                      </div>
                    )}
                  </div>
                </div>
              )
            })}
          </div>

          {/* Calendar Content Column */}
          <div className="flex-1 relative flex flex-col">
            {hours.map((hour) => {
              const hourHeight = getHourHeight(hour)
              const isExpanded = hourHeight > 40
              const hourMinutes = hour * 60

              return (
                <div
                  key={hour}
                  className="relative transition-all duration-300 ease-out border-b border-gray-200 dark:border-gray-700 group"
                  style={{ height: `${hourHeight}px` }}
                  onMouseEnter={() => !dragState.isDragging && setHoveredHour(hour)}
                  onDragEnter={() => dragState.isDragging && setHoveredHour(hour)}
                >
                  {/* Quarter hour slots */}
                  {[0, 15, 30, 45].map((quarter) => {
                    const slotMinutes = hourMinutes + quarter
                    const slotHeight = hourHeight / 4

                    return (
                      <div
                        key={`${hour}-${quarter}`}
                        className={`relative transition-all duration-300 ${
                          dragState.isDragging ? 'hover:bg-blue-50 dark:hover:bg-blue-900/10' : 'hover:bg-green-50 dark:hover:bg-green-900/10 cursor-pointer'
                        } ${
                          quarter === 0 ? 'border-t-2 border-gray-300 dark:border-gray-600' : ''
                        } ${
                          isExpanded && quarter > 0 ? 'border-t border-gray-100 dark:border-gray-800' : ''
                        }`}
                        style={{
                          height: `${slotHeight}px`,
                          cursor: dragState.isDragging ? 'default' : 'pointer'
                        }}
                        onClick={(e) => {
                          if (!dragState.isDragging && !e.defaultPrevented) {
                            setSelectedTimeSlot(minutesToTime(slotMinutes))
                            setShowEntryPanel(true)
                          }
                        }}
                      >
                        {/* Quarter hour marker - only show when expanded */}
                        {isExpanded && quarter > 0 && (
                          <div className="absolute top-0 left-0 w-4 h-px bg-gray-300 dark:bg-gray-600" />
                        )}

                        {/* Visual drop zone when dragging */}
                        {dragState.isDragging && hoveredHour === hour && (
                          <div className="absolute inset-0 bg-blue-50 dark:bg-blue-900/10 border-2 border-blue-400 dark:border-blue-500 border-dashed rounded-sm opacity-75" />
                        )}

                        {/* Click-to-create hint when expanded */}
                        {!dragState.isDragging && isExpanded && hourHeight >= 120 && quarter === 0 && (
                          <div className="absolute right-1 top-1 text-xs text-gray-400 font-mono opacity-0 group-hover:opacity-100 transition-opacity">
                            click
                          </div>
                        )}
                      </div>
                    )
                  })}
                </div>
              )
            })}

            {/* Current Time Indicator - positioned with magnification */}
            {showCurrentTime && (() => {
              // Calculate position based on magnified hours
              let cumulativeTop = 0
              for (let hour = 7; hour < currentHour; hour++) {
                cumulativeTop += getHourHeight(hour)
              }
              // Add position within the current hour
              const currentHourHeight = getHourHeight(currentHour)
              const positionInHour = (currentMinute / 60) * currentHourHeight
              const finalPosition = cumulativeTop + positionInHour

              return (
                <div
                  className="absolute left-0 right-0 z-20 pointer-events-none transition-all duration-300"
                  style={{ top: `${finalPosition}px` }}
                >
                  <div className="h-0.5 bg-red-500 relative">
                    <div className="absolute -left-1 -top-1 w-2 h-2 bg-red-500 rounded-full shadow-lg animate-pulse" />
                    <span className="absolute left-2 -top-2 text-xs font-mono text-red-500 font-bold bg-white dark:bg-gray-900 px-1 rounded">
                      {currentTime.toLocaleTimeString('en-US', {
                        hour: '2-digit',
                        minute: '2-digit',
                        hour12: false
                      })}
                    </span>
                  </div>
                </div>
              )
            })()}

            {/* Calendar Entries - positioned with magnification */}
            {entries.map((entry, index) => {
              const startMinutes = timeToMinutes(entry.start_time)
              const endMinutes = entry.end_time ? timeToMinutes(entry.end_time) : startMinutes + 60
              const duration = endMinutes - startMinutes
              const startHour = Math.floor(startMinutes / 60)
              const endHour = Math.floor(endMinutes / 60)

              if (startHour < 7 || startHour > 21) return null

              // Calculate top position with magnification
              let cumulativeTop = 0
              for (let hour = 7; hour < startHour; hour++) {
                cumulativeTop += getHourHeight(hour)
              }
              const startHourHeight = getHourHeight(startHour)
              const positionInStartHour = ((startMinutes % 60) / 60) * startHourHeight
              const topOffset = cumulativeTop + positionInStartHour

              // Calculate height with magnification - complex calculation for entries spanning multiple hours
              let entryHeight = 0
              const startMinuteInHour = startMinutes % 60
              const endMinuteInHour = endMinutes % 60

              if (startHour === endHour) {
                // Entry within single hour
                const hourHeight = getHourHeight(startHour)
                entryHeight = (duration / 60) * hourHeight
              } else {
                // Entry spans multiple hours
                // First hour partial
                const firstHourHeight = getHourHeight(startHour)
                entryHeight += ((60 - startMinuteInHour) / 60) * firstHourHeight

                // Middle hours (if any)
                for (let hour = startHour + 1; hour < endHour; hour++) {
                  entryHeight += getHourHeight(hour)
                }

                // Last hour partial
                if (endHour <= 21) {
                  const lastHourHeight = getHourHeight(endHour)
                  entryHeight += (endMinuteInHour / 60) * lastHourHeight
                }
              }

              entryHeight = Math.max(entryHeight - 4, 16) // Minimum height with padding

              // Handle overlapping entries
              const overlaps = entries.filter((otherEntry, otherIndex) => {
                if (otherIndex >= index) return false
                const otherStart = timeToMinutes(otherEntry.start_time)
                const otherEnd = otherEntry.end_time ? timeToMinutes(otherEntry.end_time) : otherStart + 60
                return (startMinutes < otherEnd && endMinutes > otherStart)
              }).length

              const leftOffset = overlaps * 50
              const width = Math.max(200 - leftOffset, 100)

              // Scale content based on whether the entry's hour is magnified
              const isInMagnifiedHour = hoveredHour && startHour <= hoveredHour && endHour >= hoveredHour
              const contentScale = isInMagnifiedHour ? 1 : 0.9 // Less aggressive scaling

              return (
                <div
                  key={entry.id}
                  id={`entry-${entry.id}`}
                  onMouseDown={(e) => {
                    e.preventDefault()

                    const startX = e.clientX
                    const startY = e.clientY
                    let isDragging = false
                    let dragStarted = false

                    const handleMouseMove = (moveEvent: MouseEvent) => {
                      const distance = Math.sqrt(
                        Math.pow(moveEvent.clientX - startX, 2) +
                        Math.pow(moveEvent.clientY - startY, 2)
                      )

                      if (distance > 5 && !dragStarted) {
                        // It's a drag - start the drag operation
                        dragStarted = true
                        isDragging = true
                        document.removeEventListener('mousemove', handleMouseMove)
                        document.removeEventListener('mouseup', handleMouseUpClick)

                        // Clear any existing selection when starting drag
                        if (selectedEntry?.id === entry.id) {
                          setSelectedEntry(null)
                        }

                        // Start the actual drag
                        handleMouseDown(e, { type: 'entry', entry })
                      }
                    }

                    const handleMouseUpClick = () => {
                      // Clean up listeners
                      document.removeEventListener('mousemove', handleMouseMove)
                      document.removeEventListener('mouseup', handleMouseUpClick)

                      // Only select if it wasn't a drag
                      if (!isDragging) {
                        setSelectedEntry(selectedEntry?.id === entry.id ? null : entry)
                      }
                    }

                    document.addEventListener('mousemove', handleMouseMove)
                    document.addEventListener('mouseup', handleMouseUpClick)
                  }}
                  className={`absolute rounded border-2 cursor-move z-30 transition-all duration-300 hover:shadow-lg hover:z-40 select-none ${
                    getStatusColor(entry.status_code)
                  } ${
                    selectedEntry?.id === entry.id ? 'ring-2 ring-blue-500' : ''
                  }`}
                  style={{
                    top: `${topOffset}px`,
                    height: `${entryHeight}px`,
                    left: `${4 + leftOffset}px`,
                    width: `${width}px`,
                    transform: `scale(${contentScale})`,
                    transformOrigin: 'left center'
                  }}
                >
                  <div className="h-full flex flex-col justify-between p-1">
                    <div>
                      <div className="font-bold truncate text-xs">{entry.task_code}</div>
                      {entryHeight > 30 && entry.work_description && entry.work_description !== 'New Entry' && (
                        <div className="opacity-75 truncate text-xs mt-0.5">{entry.work_description}</div>
                      )}
                    </div>
                    {entryHeight > 50 && (
                      <div className="opacity-60 text-xs mt-1">
                        [{entry.status_code}] {entry.start_time}
                        {entry.end_time && ` - ${entry.end_time}`}
                      </div>
                    )}
                  </div>
                </div>
              )
            })}
          </div>
        </div>
      </div>
    )
  }

  // Inline Entry Editor
  const InlineEditor = () => {
    if (!selectedEntry || !isHydrated) return null

    // Find the entry element position
    const entryElement = document.getElementById(`entry-${selectedEntry.id}`)
    if (!entryElement) return null

    let rect, windowWidth, showOnLeft
    try {
      rect = entryElement.getBoundingClientRect()
      windowWidth = window.innerWidth
      const editorWidth = 400

      // Position to the right, or left if no space
      showOnLeft = rect.right + editorWidth + 20 > windowWidth
    } catch (error) {
      console.error('Error positioning inline editor:', error)
      return null
    }

    return (
      <div
        className="fixed z-50 bg-white dark:bg-gray-900 border-2 border-blue-500
                   rounded-lg shadow-2xl p-4 w-96"
        style={{
          top: `${rect.top + window.scrollY}px`,
          ...(showOnLeft
            ? { right: `${windowWidth - rect.left + 10}px` }
            : { left: `${rect.right + 10}px` }
          )
        }}
      >
        {/* Task Code Field */}
        <input
          type="text"
          value={selectedEntry.task_code}
          onChange={(e) => {
            setSelectedEntry(prev => prev ? {...prev, task_code: e.target.value} : null)
          }}
          className="w-full mb-3 px-3 py-2 font-mono border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-800 focus:outline-none focus:ring-2 focus:ring-blue-500"
          placeholder="Task Code"
        />

        {/* Time Fields */}
        <div className="grid grid-cols-2 gap-2 mb-3">
          <div>
            <label className="block text-xs text-gray-500 mb-1">Start</label>
            <input
              type="time"
              value={selectedEntry.start_time}
              onChange={(e) => {
                setSelectedEntry(prev => prev ? {...prev, start_time: e.target.value} : null)
              }}
              className="w-full px-2 py-1 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-800 focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
          </div>
          <div>
            <label className="block text-xs text-gray-500 mb-1">End</label>
            <input
              type="time"
              value={selectedEntry.end_time || ''}
              onChange={(e) => {
                setSelectedEntry(prev => prev ? {...prev, end_time: e.target.value} : null)
              }}
              className="w-full px-2 py-1 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-800 focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
          </div>
        </div>

        {/* Status Selector - Grid like main Create page */}
        <div className="mb-3">
          <label className="block text-xs text-gray-500 mb-2">Status</label>
          <div className="grid grid-cols-3 gap-1">
            {[
              { code: 'R', label: 'Received', color: 'blue' },
              { code: 'P', label: 'Pending', color: 'yellow' },
              { code: 'D', label: 'Delivered', color: 'purple' },
              { code: 'C', label: 'Completed', color: 'green' },
              { code: 'F', label: 'Filed', color: 'gray' },
              { code: 'X', label: 'Cancelled', color: 'red' }
            ].map(status => (
              <button
                key={status.code}
                onClick={async () => {
                  await updateEntryStatus(selectedEntry.id, status.code)
                  setSelectedEntry(prev => prev ? {...prev, status_code: status.code} : null)
                }}
                className={`py-2 px-2 rounded text-xs font-mono transition-all ${
                  selectedEntry.status_code === status.code
                    ? 'bg-blue-600 text-white'
                    : 'bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600'
                }`}
              >
                {status.code}
                <div className="text-xs opacity-70">{status.label}</div>
              </button>
            ))}
          </div>
        </div>

        {/* Description */}
        <textarea
          value={selectedEntry.work_description}
          onChange={(e) => {
            setSelectedEntry(prev => prev ? {...prev, work_description: e.target.value} : null)
          }}
          className="w-full mb-3 px-3 py-2 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-800 focus:outline-none focus:ring-2 focus:ring-blue-500"
          rows={2}
          placeholder="Description"
        />

        {/* Action Buttons */}
        <div className="flex gap-2">
          <button
            onClick={async () => {
              try {
                // Save all changes
                const { error } = await supabase
                  .from('calendar_entries')
                  .update({
                    task_code: selectedEntry.task_code,
                    status_code: selectedEntry.status_code,
                    work_description: selectedEntry.work_description,
                    start_time: selectedEntry.start_time,
                    end_time: selectedEntry.end_time
                  })
                  .eq('id', selectedEntry.id)

                if (error) {
                  console.error('Error updating entry:', error)
                  alert('Error saving changes: ' + error.message)
                  return
                }

                setSelectedEntry(null)
                loadEntries()
              } catch (err) {
                console.error('Unexpected error:', err)
                alert('Unexpected error occurred while saving')
              }
            }}
            className="flex-1 bg-blue-600 text-white py-2 rounded hover:bg-blue-700 transition-colors font-mono text-sm"
          >
            Save
          </button>
          <button
            onClick={() => deleteEntry(selectedEntry.id)}
            className="flex-1 bg-red-600 text-white py-2 rounded hover:bg-red-700 transition-colors font-mono text-sm"
          >
            Delete
          </button>
          <button
            onClick={() => setSelectedEntry(null)}
            className="flex-1 bg-gray-400 text-white py-2 rounded hover:bg-gray-500 transition-colors font-mono text-sm"
          >
            Cancel
          </button>
        </div>
      </div>
    )
  }

  // Task Search Modal - Search for existing tasks to schedule
  const TaskSearchModal = () => {
    const [searchQuery, setSearchQuery] = useState('')
    const [searchResults, setSearchResults] = useState<Task[]>([])
    const [isSearching, setIsSearching] = useState(false)

    if (!showEntryPanel) return null

    // Search functionality (reused from Navigation)
    useEffect(() => {
      const searchTasks = async () => {
        if (!searchQuery.trim()) {
          setSearchResults([])
          setIsSearching(false)
          return
        }

        setIsSearching(true)
        try {
          // Search in tasks by title, code, and base_code
          const { data: taskResults } = await supabase
            .from('task_details')
            .select('*')
            .or(`title.ilike.%${searchQuery}%,code.ilike.%${searchQuery}%,base_code.ilike.%${searchQuery}%,display_code.ilike.%${searchQuery}%`)
            .limit(10)

          setSearchResults(taskResults || [])
        } catch (error) {
          console.error('Search error:', error)
          setSearchResults([])
        } finally {
          setIsSearching(false)
        }
      }

      // Debounce search
      const timeoutId = setTimeout(searchTasks, 300)
      return () => clearTimeout(timeoutId)
    }, [searchQuery])

    const handleTaskSelect = async (task: Task) => {
      await createEntryAtTime(task, selectedTimeSlot)
      handleCancel()
    }

    const handleCancel = () => {
      setShowEntryPanel(false)
      setSearchQuery('')
      setSearchResults([])
    }

    return (
      <div className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4">
        <div className="bg-gray-900 border border-gray-700 rounded-lg w-full max-w-2xl shadow-2xl max-h-96 flex flex-col">
          <div className="p-4 border-b border-gray-700">
            <div className="text-sm font-mono text-gray-400 mb-2">
              Schedule task at {selectedTimeSlot} on {currentDate.toLocaleDateString()}
            </div>
            <input
              type="text"
              placeholder="Search existing tasks..."
              className="w-full bg-transparent text-white font-mono text-lg focus:outline-none"
              autoFocus
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              onKeyDown={(e) => {
                if (e.key === 'Escape') {
                  handleCancel()
                }
                if (e.key === 'Enter' && searchResults.length > 0) {
                  handleTaskSelect(searchResults[0])
                }
              }}
            />
          </div>

          <div className="flex-1 overflow-y-auto">
            {isSearching && (
              <div className="p-4 text-gray-500 font-mono text-sm text-center">
                Searching...
              </div>
            )}

            {!isSearching && searchQuery && searchResults.length === 0 && (
              <div className="p-4 text-gray-500 font-mono text-sm text-center">
                No tasks found matching "{searchQuery}"
              </div>
            )}

            {!isSearching && searchResults.length > 0 && (
              <div className="py-2">
                {searchResults.map((task, index) => (
                  <button
                    key={task.id}
                    onClick={() => handleTaskSelect(task)}
                    className="w-full text-left px-4 py-3 hover:bg-gray-800 font-mono border-b border-gray-700 last:border-b-0"
                  >
                    <div className="flex items-center justify-between">
                      <div className="flex-1">
                        <div className="text-white font-bold text-sm sm:text-base">
                          {task.display_code || task.base_code || task.code} - {task.title}
                        </div>
                        <div className="text-xs text-gray-400 mt-1">
                          {(task as any).universe_name || 'Unknown'} {' > '} {(task as any).phylum_name || 'Unknown'}
                          {(task as any).family_name && ` > ${(task as any).family_name}`} {' > '} {(task as any).group_name || 'Unknown'}
                        </div>
                        {task.current_status_name && (
                          <div className="text-xs text-yellow-400 mt-1">
                            Status: {task.current_status_name}
                          </div>
                        )}
                      </div>
                      <div className="text-gray-500 text-xs ml-4 hidden sm:block">
                        {index === 0 && 'Enter'}
                      </div>
                    </div>
                  </button>
                ))}
              </div>
            )}

            {!searchQuery && (
              <div className="p-4 text-gray-500 font-mono text-sm">
                <p>Type to search for existing tasks to schedule</p>
                <p className="mt-2">• Search by task title, code, or identifier</p>
                <p>• Press Enter to select first result</p>
                <p>• Press ESC to cancel</p>
              </div>
            )}
          </div>

          <div className="p-4 border-t border-gray-700 flex justify-end">
            <button
              onClick={handleCancel}
              className="px-6 py-2 bg-gray-600 text-white font-mono rounded-lg hover:bg-gray-500 transition-colors"
            >
              Cancel
            </button>
          </div>
        </div>
      </div>
    )
  }

  return (
    <div className="min-h-screen bg-[#F8F7F4] dark:bg-[#0A0A0B] p-4">
      <div className="max-w-full mx-auto">
        <div className="mb-4 pb-4 border-b-2 border-gray-900 dark:border-gray-300">
          <div className="flex items-center justify-between font-mono">
            <h1 className="text-xl font-bold">{formatDate()}</h1>
            <div className="flex items-center space-x-2">
              <button onClick={() => navigate('prev')} className="text-lg px-2">[&lt;]</button>
              <button
                onClick={() => setCurrentDate(new Date())}
                className="px-2 py-1 bg-gray-200 dark:bg-gray-700 rounded text-xs"
              >
                TODAY
              </button>
              <button onClick={() => navigate('next')} className="text-lg px-2">[&gt;]</button>

              {/* Divider */}
              <div className="w-px h-6 bg-gray-400 mx-2" />

              {/* TASKS button in header */}
              <button
                onClick={() => setShowTaskPanel(!showTaskPanel)}
                className={`px-3 py-1 rounded text-xs font-mono transition-colors ${
                  showTaskPanel
                    ? 'bg-green-600 hover:bg-green-700 text-white'
                    : 'bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600'
                }`}
              >
                [TASKS]
              </button>

              <button
                className="px-2 py-1 bg-blue-600 text-white rounded text-xs hover:bg-blue-700 transition-colors"
                onClick={() => alert('Generating SOA...')}
              >
                [SOA]
              </button>
            </div>
          </div>
        </div>

        <div className={`transition-all duration-300 ${showTaskPanel && !isMobile ? 'mr-80' : ''}`}>
          <div className="flex gap-4">
            <div className="flex-1">
              <CalendarGrid />
              <InlineEditor />
            </div>
          </div>
        </div>


        <TaskPanel />
        <TaskSearchModal />

      </div>
    </div>
  )
}